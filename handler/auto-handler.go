// Auto-generated by "nex regen" at "2017-11-13 21:16:49.016348 +0800 CST"
// ** DO NOT EDIT **

package handler

import (
	"context"
	"fmt"
	"io/ioutil"
	"path/filepath"
	"reflect"

	"github.com/damnever/cc"
	"github.com/eleme/huskar/config"
	"github.com/eleme/huskar/toggle"
	"github.com/eleme/nex"
	"github.com/eleme/nex/app"
	"github.com/eleme/nex/circuitbreaker"
	"github.com/eleme/nex/consts/ctxkeys"
	"github.com/eleme/nex/endpoint"
	"github.com/eleme/nex/hook"
	"github.com/eleme/nex/limits"
	"github.com/eleme/nex/log"
	"github.com/eleme/nex/metric"
	"github.com/eleme/nex/timeout"
	"github.com/eleme/nex/toggler"
	"github.com/eleme/nex/tracking/etrace"
	ttracker "github.com/eleme/nex/tracking/thrift"
	"github.com/eleme/nex/utils"
	json "github.com/json-iterator/go"

	"github.com/apache/thrift/lib/go/thrift"

	"github.com/eleme/purchaseMeiTuan/services/player"
)

var appErrTypes = &endpoint.ErrTypes{
	UserErr:  reflect.TypeOf(player.NewplayerUserException()),
	SysErr:   reflect.TypeOf(player.NewplayerSystemException()),
	UnkwnErr: reflect.TypeOf(player.NewplayerUnknownException()),
}
var errServerStoping = &player.playerUnknownException{
	ErrorCode: 0,
	ErrorName: "ServerStoping",
	Message:   "server is stoping, reject any ping request",
}

type serverStoping struct {
	C chan struct{}
}

func newServerStoping() *serverStoping {
	srvstoping := &serverStoping{C: make(chan struct{})}
	hook.BeforeServerStoping.Register(srvstoping)
	return srvstoping
}

var srvstoping = newServerStoping()

func (o *serverStoping) OnNotify(_ interface{}) {
	close(o.C)
}

// ExtMiddlewareChain is used to add custom moddlewares.
var ExtMiddlewareChain endpoint.Middleware

// thriftProcessFactroy implements thrift.TProcessor interface.
type thriftProcessFactroy struct {
	service           Service
	appName           string
	loggers           map[string]log.RPCContextLogger
	trace             *etrace.Trace
	cb                *circuitbreaker.CircuitBreaker
	huskarToggler     toggle.Toggler
	huskarConfiger    config.Configer
	tdefProcessorFunc player.CtxTProcessorFunction
	limitsCh          chan struct{}
}

// NewPlayerServiceProcessorFactory creates a processor factory.
func NewPlayerServiceProcessorFactory() thrift.TProcessorFactory {
	svcCfg, err := findConfigFromRPCDepsFile("player")
	utils.Must(err)
	nexConfig := nex.GetNexConfig()
	loggers := map[string]log.RPCContextLogger{}

	{
		logger, err := log.GetContextLogger("nex.AssignTanks")
		utils.Must(err)
		loggers["AssignTanks"] = logger
	}
	{
		logger, err := log.GetContextLogger("nex.GetNewOrders")
		utils.Must(err)
		loggers["GetNewOrders"] = logger
	}
	{
		logger, err := log.GetContextLogger("nex.LatestState")
		utils.Must(err)
		loggers["LatestState"] = logger
	}
	{
		logger, err := log.GetContextLogger("nex.UploadMap")
		utils.Must(err)
		loggers["UploadMap"] = logger
	}
	{
		logger, err := log.GetContextLogger("nex.UploadParamters")
		utils.Must(err)
		loggers["UploadParamters"] = logger
	}
	var trace *etrace.Trace
	if nexConfig.Config("plugins").Bool("etrace") {
		trace = nex.GetETrace()
	} else {
		trace = nil
	}
	var limitsCh chan struct{}
	if nexConfig.Has("max_requests_in_progress") {
		n := nexConfig.Int("max_requests_in_progress")
		limitsCh = make(chan struct{}, n)
	}
	return &thriftProcessFactroy{
		service:           NewPlayerService(),
		appName:           nexConfig.String("app_name"),
		loggers:           loggers,
		trace:             trace,
		cb:                circuitbreaker.New("PlayerService", appErrTypes),
		huskarToggler:     nex.GetHuskarToggler(),
		huskarConfiger:    nex.GetHuskarConfiger(),
		tdefProcessorFunc: app.NewNexThriftDefinitionCtxProcessorFunc(filepath.Join("thriftfs", svcCfg.String("ThriftFile"))),
		limitsCh:          limitsCh,
	}
}

// GetProcessor act as a factory to create a processor.
func (p *thriftProcessFactroy) GetProcessor(trans thrift.TTransport) thrift.TProcessor {
	soaArgs := &endpoint.SOAMiddlewareArgs{
		AppID:             p.appName,
		ThriftServiceName: "PlayerService",
		RemoteAddr:        trans.(*thrift.TSocket).Addr().String(),
		ErrTypes:          appErrTypes,
	}
	handler := p.makeThriftHandler(soaArgs)
	tracker := ttracker.NewTracker(p.appName)
	processor := player.NewPlayerServiceProcessor(tracker, handler)
	processor.AddToProcessorMap(app.ThriftDefinitionAPIName, p.tdefProcessorFunc)
	return processor
}

func findConfigFromRPCDepsFile(name string) (cc.Configer, error) {
	content, err := ioutil.ReadFile("thriftfs/deps.json")
	if err != nil {
		return nil, err
	}
	var deps []map[string]interface{}
	if err := json.Unmarshal(content, &deps); err != nil {
		return nil, err
	}
	for _, cfg := range deps {
		if cfg["Name"] == name {
			return cc.NewConfigFrom(cfg), nil
		}
	}
	return nil, fmt.Errorf("No config section found for '%v'", name)
}

// Service is a interface same as PlayerService implemented.
type Service interface {
	AssignTanks(ctx context.Context, tanks []int32) error
	GetNewOrders(ctx context.Context) ([]*player.Order, error)
	LatestState(ctx context.Context, state *player.GameState) error
	Ping(ctx context.Context) (bool, error)
	UploadMap(ctx context.Context, gamemap [][]int32) error
	UploadParamters(ctx context.Context, arguments *player.Args_) error
}

// makeThriftHandler create a wrapper of PlayerService with some middlewares.
func (p *thriftProcessFactroy) makeThriftHandler(soaArgs *endpoint.SOAMiddlewareArgs) *thriftHandler {
	// XXX: export endpoint so others can wrap middlewares?

	var assigntanksEndpoint endpoint.Endpoint
	{
		assigntanksEndpoint = makeAssignTanksEndpoint(p.service)
		// NOTE: Add middlewares here
		if ExtMiddlewareChain != nil {
			assigntanksEndpoint = ExtMiddlewareChain(assigntanksEndpoint)
		}
		assigntanksEndpoint = timeout.EndpointTimeoutSOAServerMiddleware(p.huskarConfiger)(assigntanksEndpoint)
		assigntanksEndpoint = circuitbreaker.EndpointCircuitBreakerSOAServerMiddleware(p.cb)(assigntanksEndpoint)
		if p.limitsCh != nil {
			assigntanksEndpoint = limits.EndpointMaxRequestsInProgressMiddleware(p.limitsCh)(assigntanksEndpoint)
		}
		assigntanksEndpoint = toggler.EndpointHuskarTogglerSOAServerMiddleware(p.huskarToggler)(assigntanksEndpoint)
		if p.trace != nil {
			assigntanksEndpoint = etrace.EndpointEtraceSOAServerMiddleware(p.trace, soaArgs)(assigntanksEndpoint)
		}
		assigntanksEndpoint = metric.EndpointStatsdSOAServerMiddleware(soaArgs)(assigntanksEndpoint)
		// logging middleware must be the last one.
		assigntanksEndpoint = log.EndpointLoggingSOAServerMiddleware(p.loggers["AssignTanks"], soaArgs)(assigntanksEndpoint)
	}

	var getnewordersEndpoint endpoint.Endpoint
	{
		getnewordersEndpoint = makeGetNewOrdersEndpoint(p.service)
		// NOTE: Add middlewares here
		if ExtMiddlewareChain != nil {
			getnewordersEndpoint = ExtMiddlewareChain(getnewordersEndpoint)
		}
		getnewordersEndpoint = timeout.EndpointTimeoutSOAServerMiddleware(p.huskarConfiger)(getnewordersEndpoint)
		getnewordersEndpoint = circuitbreaker.EndpointCircuitBreakerSOAServerMiddleware(p.cb)(getnewordersEndpoint)
		if p.limitsCh != nil {
			getnewordersEndpoint = limits.EndpointMaxRequestsInProgressMiddleware(p.limitsCh)(getnewordersEndpoint)
		}
		getnewordersEndpoint = toggler.EndpointHuskarTogglerSOAServerMiddleware(p.huskarToggler)(getnewordersEndpoint)
		if p.trace != nil {
			getnewordersEndpoint = etrace.EndpointEtraceSOAServerMiddleware(p.trace, soaArgs)(getnewordersEndpoint)
		}
		getnewordersEndpoint = metric.EndpointStatsdSOAServerMiddleware(soaArgs)(getnewordersEndpoint)
		// logging middleware must be the last one.
		getnewordersEndpoint = log.EndpointLoggingSOAServerMiddleware(p.loggers["GetNewOrders"], soaArgs)(getnewordersEndpoint)
	}

	var lateststateEndpoint endpoint.Endpoint
	{
		lateststateEndpoint = makeLatestStateEndpoint(p.service)
		// NOTE: Add middlewares here
		if ExtMiddlewareChain != nil {
			lateststateEndpoint = ExtMiddlewareChain(lateststateEndpoint)
		}
		lateststateEndpoint = timeout.EndpointTimeoutSOAServerMiddleware(p.huskarConfiger)(lateststateEndpoint)
		lateststateEndpoint = circuitbreaker.EndpointCircuitBreakerSOAServerMiddleware(p.cb)(lateststateEndpoint)
		if p.limitsCh != nil {
			lateststateEndpoint = limits.EndpointMaxRequestsInProgressMiddleware(p.limitsCh)(lateststateEndpoint)
		}
		lateststateEndpoint = toggler.EndpointHuskarTogglerSOAServerMiddleware(p.huskarToggler)(lateststateEndpoint)
		if p.trace != nil {
			lateststateEndpoint = etrace.EndpointEtraceSOAServerMiddleware(p.trace, soaArgs)(lateststateEndpoint)
		}
		lateststateEndpoint = metric.EndpointStatsdSOAServerMiddleware(soaArgs)(lateststateEndpoint)
		// logging middleware must be the last one.
		lateststateEndpoint = log.EndpointLoggingSOAServerMiddleware(p.loggers["LatestState"], soaArgs)(lateststateEndpoint)
	}

	var pingEndpoint endpoint.Endpoint
	{
		pingEndpoint = makePingEndpoint(p.service)
		// NOTE: Add middlewares here
		if ExtMiddlewareChain != nil {
			pingEndpoint = ExtMiddlewareChain(pingEndpoint)
		}
		pingEndpoint = toggler.EndpointHuskarTogglerSOAServerMiddleware(p.huskarToggler)(pingEndpoint)
	}

	var uploadmapEndpoint endpoint.Endpoint
	{
		uploadmapEndpoint = makeUploadMapEndpoint(p.service)
		// NOTE: Add middlewares here
		if ExtMiddlewareChain != nil {
			uploadmapEndpoint = ExtMiddlewareChain(uploadmapEndpoint)
		}
		uploadmapEndpoint = timeout.EndpointTimeoutSOAServerMiddleware(p.huskarConfiger)(uploadmapEndpoint)
		uploadmapEndpoint = circuitbreaker.EndpointCircuitBreakerSOAServerMiddleware(p.cb)(uploadmapEndpoint)
		if p.limitsCh != nil {
			uploadmapEndpoint = limits.EndpointMaxRequestsInProgressMiddleware(p.limitsCh)(uploadmapEndpoint)
		}
		uploadmapEndpoint = toggler.EndpointHuskarTogglerSOAServerMiddleware(p.huskarToggler)(uploadmapEndpoint)
		if p.trace != nil {
			uploadmapEndpoint = etrace.EndpointEtraceSOAServerMiddleware(p.trace, soaArgs)(uploadmapEndpoint)
		}
		uploadmapEndpoint = metric.EndpointStatsdSOAServerMiddleware(soaArgs)(uploadmapEndpoint)
		// logging middleware must be the last one.
		uploadmapEndpoint = log.EndpointLoggingSOAServerMiddleware(p.loggers["UploadMap"], soaArgs)(uploadmapEndpoint)
	}

	var uploadparamtersEndpoint endpoint.Endpoint
	{
		uploadparamtersEndpoint = makeUploadParamtersEndpoint(p.service)
		// NOTE: Add middlewares here
		if ExtMiddlewareChain != nil {
			uploadparamtersEndpoint = ExtMiddlewareChain(uploadparamtersEndpoint)
		}
		uploadparamtersEndpoint = timeout.EndpointTimeoutSOAServerMiddleware(p.huskarConfiger)(uploadparamtersEndpoint)
		uploadparamtersEndpoint = circuitbreaker.EndpointCircuitBreakerSOAServerMiddleware(p.cb)(uploadparamtersEndpoint)
		if p.limitsCh != nil {
			uploadparamtersEndpoint = limits.EndpointMaxRequestsInProgressMiddleware(p.limitsCh)(uploadparamtersEndpoint)
		}
		uploadparamtersEndpoint = toggler.EndpointHuskarTogglerSOAServerMiddleware(p.huskarToggler)(uploadparamtersEndpoint)
		if p.trace != nil {
			uploadparamtersEndpoint = etrace.EndpointEtraceSOAServerMiddleware(p.trace, soaArgs)(uploadparamtersEndpoint)
		}
		uploadparamtersEndpoint = metric.EndpointStatsdSOAServerMiddleware(soaArgs)(uploadparamtersEndpoint)
		// logging middleware must be the last one.
		uploadparamtersEndpoint = log.EndpointLoggingSOAServerMiddleware(p.loggers["UploadParamters"], soaArgs)(uploadparamtersEndpoint)
	}

	return &thriftHandler{
		assigntanks:     assigntanksEndpoint,
		getneworders:    getnewordersEndpoint,
		lateststate:     lateststateEndpoint,
		ping:            pingEndpoint,
		uploadmap:       uploadmapEndpoint,
		uploadparamters: uploadparamtersEndpoint,
	}
}

// thriftHandler is a wrapper for PlayerService with middlewares that can be passed to thrift processor.
type thriftHandler struct {
	assigntanks     endpoint.Endpoint
	getneworders    endpoint.Endpoint
	lateststate     endpoint.Endpoint
	ping            endpoint.Endpoint
	uploadmap       endpoint.Endpoint
	uploadparamters endpoint.Endpoint
}

// AssignTanks is a method that is compatible with thrift definition.
func (h *thriftHandler) AssignTanks(ctx context.Context, tanks []int32) error {
	// Passing context values.
	ctx = context.WithValue(ctx, ctxkeys.APIName, "assignTanks")

	request := assigntanksRequest{Tanks: tanks}
	_, err := h.assigntanks(ctx, request)
	return err
}

// GetNewOrders is a method that is compatible with thrift definition.
func (h *thriftHandler) GetNewOrders(ctx context.Context) ([]*player.Order, error) {
	// Passing context values.
	ctx = context.WithValue(ctx, ctxkeys.APIName, "getNewOrders")

	request := getnewordersRequest{}
	response, err := h.getneworders(ctx, request)
	if err != nil {
		var v []*player.Order
		return v, err
	}
	resp := response.(getnewordersResponse)
	return resp.V, err
}

// LatestState is a method that is compatible with thrift definition.
func (h *thriftHandler) LatestState(ctx context.Context, state *player.GameState) error {
	// Passing context values.
	ctx = context.WithValue(ctx, ctxkeys.APIName, "latestState")

	request := lateststateRequest{State: state}
	_, err := h.lateststate(ctx, request)
	return err
}

// Ping is a method that is compatible with thrift definition.
func (h *thriftHandler) Ping(ctx context.Context) (bool, error) {
	// Passing context values.
	ctx = context.WithValue(ctx, ctxkeys.APIName, "ping")
	select {
	case <-srvstoping.C:
		var v bool
		return v, errServerStoping
	default:
	}

	request := pingRequest{}
	response, err := h.ping(ctx, request)
	if err != nil {
		var v bool
		return v, err
	}
	resp := response.(pingResponse)
	return resp.V, err
}

// UploadMap is a method that is compatible with thrift definition.
func (h *thriftHandler) UploadMap(ctx context.Context, gamemap [][]int32) error {
	// Passing context values.
	ctx = context.WithValue(ctx, ctxkeys.APIName, "uploadMap")

	request := uploadmapRequest{Gamemap: gamemap}
	_, err := h.uploadmap(ctx, request)
	return err
}

// UploadParamters is a method that is compatible with thrift definition.
func (h *thriftHandler) UploadParamters(ctx context.Context, arguments *player.Args_) error {
	// Passing context values.
	ctx = context.WithValue(ctx, ctxkeys.APIName, "uploadParamters")

	request := uploadparamtersRequest{Arguments: arguments}
	_, err := h.uploadparamters(ctx, request)
	return err
}
